# 简化的RV32I指令测试程序
# 测试新添加的指令功能

# 初始化数据
addi x1, x0, 5      # x1 = 5
addi x2, x0, 2      # x2 = 2
addi x3, x0, -4     # x3 = -4

# === U型指令测试 ===
lui   x4, 0x12345   # x4 = 0x12345000
auipc x5, 0x1000    # x5 = PC + 0x1000000

# === 新的内存访问指令测试 ===
# 准备测试数据
addi x6, x0, 0x5A   # 测试字节数据
sb   x6, 0(x0)      # 存储字节到地址0

addi x7, x0, 0x1234 # 测试半字数据  
sh   x7, 4(x0)      # 存储半字到地址4

# 加载测试
lb   x8, 0(x0)      # 加载字节(有符号)
lbu  x9, 0(x0)      # 加载字节(无符号)
lh   x10, 4(x0)     # 加载半字(有符号)
lhu  x11, 4(x0)     # 加载半字(无符号)

# === 简单跳转测试 ===
jal  x12, 8         # 跳转8字节，保存返回地址
addi x13, x0, 999   # 这条不应该执行

# 跳转目标 (当前PC + 8)
addi x14, x0, 42    # 跳转后执行这条

# JALR测试 - 跳转到x12保存的地址+4  
jalr x15, x12, 4    # 跳转到返回地址+4
addi x16, x0, 888   # 这条不应该执行

# JALR目标
addi x17, x0, 123   # 最终执行这条

# FENCE指令测试
fence

# 结束循环
beq x0, x0, 0       # 无限循环
